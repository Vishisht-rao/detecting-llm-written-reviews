Write a review for the following paper.

Abstract: Optunity is a free software package dedicated to hyperparameter optimization. It contains various types of solvers, ranging from undirected methods to direct search, particle swarm and evolutionary optimization. The design focuses on ease of use, flexibility, code clarity and interoperability with existing software in all machine learning environments. Optunity is written in Python and contains interfaces to environments such as R and MATLAB. Optunity uses a BSD license and is freely available online at http://www.optunity.net.

1. Introduction: Many machine learning tasks aim to train a model M which minimizes some loss function L(M |X(te)) on given test data X(te). A model is obtained via a learning algorithm A which uses a training set X(tr) and solves some optimization problem. The learning algorithm A may itself be parameterized by a set of hyperparameters λ, e.g. M = A(X(tr) | λ). Hyperparameter search – also known as tuning – aims to find a set of hyperparameters λ∗, such that the learning algorithm yields an optimal modelM∗ that minimizes L(M | X(te)):
λ∗ = arg min λ
L ( A(X(tr) | λ) | X(te) ) = arg min
λ F(λ | A, X(tr),X(te), L) (1)
In the context of tuning, F is the objective function and λ is a tuple of hyperparameters (optimization variables). The learning algorithm A and data sets X(tr) and X(te) are known. Depending on the learning task, X(tr) and X(te) may be labeled and/or equal to each other. The objective function often has a constrained domain (for example regularization terms must be positive) and is assumed to be expensive to evaluate, black-box and non-smooth.
Tuning hyperparameters is a recurrent task in many machine learning approaches. Some common hyperparameters that must be tuned are related to kernels, regularization, learning rates and network architecture. Tuning can be necessary in both supervised and unsupervised settings and may significantly impact the resulting model’s performance.
c© Marc Claesen, Jaak Simm, Dusan Popovic, Yves Moreau and Bart De Moor.
ar X
iv :1
41 2.
11 14
v1 [
cs .L
G ]
General machine learning packages typically provide only basic tuning methods like grid search. The most common tuning approaches are grid search and manual tuning (Hsu et al., 2003; Hinton, 2012). Grid search suffers from the curse of dimensionality when the number of hyperparameters grows large while manual tuning requires considerable expertise which leads to poor reproducibility, particularly when many hyperparameters are involved.

2. Optunity: Our software is a Swiss army knife for hyperparameter search. Optunity offers a series of configurable optimization methods and utility functions that enable efficient hyperparameter optimization. Only a handful of lines of code are necessary to perform tuning. Optunity should be used in tandem with existing machine learning packages that implement learning algorithms. The package uses a BSD license and is simple to deploy in any environment. Optunity has been tested in Python, R and MATLAB on Linux, OSX and Windows.

2.1 Functional overview: Optunity provides both simple routines for lay users and expert routines that enable finegrained control of various aspects of the solving process. Basic tuning can be performed with minimal configuration, requiring only an objective function, an upper limit on the number of evaluations and box constraints on the hyperparameters to be optimized.
The objective function must be defined by the user. It takes a hyperparameter tuple λ and typically involves three steps: (i) training a model M with λ, (ii) use M to predict a test set (iii) compute some score or loss based on the predictions. In unsupervised tasks, the separation between (i) and (ii) need not exist, for example in clustering a data set.
Tuning involves a series of function evaluations until convergence or until a predefined maximum number of evaluations is reached. Optunity is capable of vectorizing evaluations in the working environment to speed up the process at the end user’s volition.
Optunity additionally provides k-fold cross-validation to estimate the generalization performance of supervised modeling approaches. The cross-validation implementation can account for strata and clusters.1 Finally, a variety of common quality metrics is available.
The code example below illustrates tuning an SVM with scikit-learn and Optunity.2
1 @optunity.cross_validated(x=data, y=labels, num_folds=10, num_iter=2) 2 def svm auc(x_train, y_train, x_test, y_test, C, gamma): 3 model = sklearn.svm.SVC(C=C, gamma=gamma).fit(x_train, y_train) 4 decision_values = model.decision_function(x_test) 5 return optunity.metrics.roc_auc(y_test, decision_values) 6 7 optimal_pars, _, _ = optunity.maximize(svm auc, num_evals=100, C=[0, 10], gamma=[0, 1]) 8 optimal_model = sklearn.svm.SVC(**optimal_pars).fit(data, labels)
The objective function as per Equation (1) is defined on lines 1 to 5, where λ = (C, γ), A is the SVM training algorithm and L is area under the ROC curve. We use 2× iterated 10-fold cross-validation to estimate area under the ROC curve. Up to 100 hyperparameter tuples are tested within the box constraints 0 < C < 10 and 0 < γ < 1 on line 7.
1. Instances in a stratum should be spread across folds. Clustered instances must remain in a single fold. 2. We assume the correct imports are made and data and labels contain appropriate content.

2.2 Available solvers: Optunity provides a wide variety of solvers, ranging from basic, undirected methods like grid search and random search (Bergstra and Bengio, 2012) to evolutionary methods such as particle swarm optimization (Kennedy, 2010) and the covariance matrix adaptation evolutionary strategy (CMA-ES) (Hansen and Ostermeier, 2001). Finally, we provide the Nelder-Mead simplex (Nelder and Mead, 1965), which is useful for local search after a good region has been determined. Optunity’s current default solver is particle swarm optimization, as our experiments have shown it to perform well for a large variety of tuning tasks involving various learning algorithms. Additional solvers will be incorporated in the future.

2.3 Software design and implementation: The design philosophy of Optunity prioritizes code clarity over performance. This is justified by the fact that objective function evaluations constitute the real performance bottleneck.
In contrast to typical Python packages, we avoid dependencies on big packages like NumPy/SciPy and scikit-learn to facilitate users working in non-Python environments (sometimes at the cost of performance). To prevent issues for users that are unfamiliar with Python, care is taken to ensure all code in Optunity works out of the box on any Python version above 2.7, without requiring tools like 2to3 to make explicit conversions. Optunity has a single dependency on DEAP (Fortin et al., 2012) for the CMA-ES solver.
A key aspect of Optunity’s design is interoperability with external environments. This requires bidirectional communication between Optunity’s Python back-end (O) and the external environment (E) and roughly involves three steps: (i) E → O solver configuration, (ii) O ↔ E objective function evaluations and (iii) O → E solution and solver summary. To this end, Optunity can do straightforward communication with any environment via sockets using JSON messages as shown in Figure 1. Only some information must be communicated, big objects like data sets are never exchanged. To port Optunity to a new environment, a thin wrapper must be implemented to handle communication.

2.4 Documentation: Code is documented using Sphinx and contains many doctests that can serve as both unit tests and examples of the associated functions. Our website contains API documentation, user documentation and a wide range of examples to illustrate all aspects of the software. The examples involve various packages, including scikit-learn (Pedregosa et al., 2011), OpenCV (Bradski, 2